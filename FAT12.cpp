#include "FAT12.h"
#include "dir.h"

Disk disk;
RootEntry root;

FILE *diskFile = fopen(PATH, "rb");

/**
 * 读取镜像的FAT到本地磁盘
 */
void read_fat_from_vfd(char *vfd_file) {
    fseek(diskFile, 512, SEEK_SET);
    fread(&disk.FAT1, sizeof(FATEntry), 1536, diskFile);
}

/**
 * 读取镜像的mbr到本地磁盘
 */
void read_mbr_from_vfd(char *vfd_file) {
    //一个MBR也就是512字节 申请512字节空间
    MBRHeader *mbr = (MBRHeader *) malloc(sizeof(MBRHeader));
    fseek(diskFile, 0, SEEK_SET);
    uint32_t readed_size = fread(mbr, 1, SECTOR_SIZE, diskFile);
    if (readed_size != SECTOR_SIZE) {
        perror("文件读取错误,请检查是否路径正确");
        free(mbr);
        return;
    }
    disk.MBR = *mbr;
    uint32_t rootDirStartSec = 1 + (disk.MBR.BPB_NumFATs * disk.MBR.BPB_FATSz16); // 1 MBR，2 是 FAT 表的扇区数
    fseek(diskFile, rootDirStartSec * SECTOR_SIZE, SEEK_SET); //移动到根目录区了
    uint16_t read_size = fread(disk.rootDirectory, sizeof(RootEntry), disk.MBR.BPB_RootEntCnt, diskFile);
    if (read_size != 224) {  //本地写死 老师提供的磁盘为112
        perror("读取根目录失败，请检查文件");
        fclose(diskFile);
        return;
    }
    free(mbr);
}

/**
 * 查找文件Entry块
 */
RootEntry *findFile(string &fileName) {
    if (fileName.empty()) {
        cout << "待查找为空";
        return NULL;
    }
    uint16_t dotPosition = fileName.find('.');  //用.分割前后
    string baseName = (dotPosition == string::npos) ? fileName : fileName.substr(0, dotPosition);
    string extension = (dotPosition == string::npos) ? "" : fileName.substr(dotPosition + 1);

    for (int i = 0; i < disk.MBR.BPB_RootEntCnt; i++) {
        // 跳过空条目
        if (disk.rootDirectory[i].DIR_Name[0] == 0) continue;

        // 从目录条目中提取文件名和扩展名
        char _name[9] = "";
        char _ext[4] = "";

        memcpy(_name, disk.rootDirectory[i].DIR_Name, 8);
        memcpy(_ext, disk.rootDirectory[i].DIR_Name + 8, 3);

        // 创建标准化的文件名和扩展名
        string origin_file_name = string(_name);
        string origin_file_ext = string(_ext);

        //去除空格
        origin_file_name = origin_file_name.substr(0, origin_file_name.find_last_not_of(' ') + 1);
        origin_file_ext = origin_file_ext.substr(0, origin_file_name.find_last_not_of(' ') + 1);

        //比较文件名和扩展名，忽略大小写
        bool isNameMatch = strcasecmp(origin_file_name.c_str(), baseName.c_str()) == 0;
        bool isExtMatch = strcasecmp(origin_file_ext.c_str(), extension.c_str()) == 0;

        if (isNameMatch && isExtMatch) {
            return &disk.rootDirectory[i]; // 返回找到的文件条目
        }
    }
    return NULL;
}

/**
 * 从给定的缓冲区获取下一个簇号
 * @param buffer 指向存储 FAT 数据的缓冲区
 * @param flag 指示位，用于决定如何读取簇号
 * @return 返回下一个簇号
 */
unsigned short getClus(unsigned char *buffer, char flag) {
    uint16_t ans = 0;
    if (!flag) {
        ans += buffer[0];
        ans += (buffer[1] << 8) & 0xFFF; // 只取低12位
    } else {
        ans += buffer[1] << 4;
        ans += buffer[0] >> 4; // 取高4位
    }
    return ans;
}


/**
 * 读取文件数据
 * @param firstCluster 第一个簇号
 * @param fileSize 文件大小
 */
void readFileData(uint16_t firstCluster, uint32_t fileSize) {
    uint8_t sectorsPerCluster = disk.MBR.BPB_SecPerClus; // 每个簇的扇区数
    uint32_t fatSize = disk.MBR.BPB_FATSz16; // FAT 的大小
    uint32_t fatStartSector = 1; // FAT 起始扇区
    uint32_t dataStartSector = fatStartSector + (disk.MBR.BPB_NumFATs * fatSize) +
                               (disk.MBR.BPB_RootEntCnt * sizeof(RootEntry) / disk.MBR.BPB_BytesPerSec);

    uint16_t currentCluster = firstCluster;
    uint32_t bytesRead = 0;

    while (bytesRead < fileSize) {
        // 计算当前簇对应的起始扇区
        uint32_t clusterSector = dataStartSector + (currentCluster - 2) * sectorsPerCluster;
        // 用于存储读取的字节
        uint8_t buffer[SECTOR_SIZE];
        // 逐扇区读取数据
        for (uint8_t sector = 0; sector < sectorsPerCluster; ++sector) {
            if (bytesRead >= fileSize) break; // 如果已读取完毕，退出循环

            FILE *boot = fopen(PATH, "rb");
            // 读取当前扇区
            fseek(boot, (clusterSector + sector) * SECTOR_SIZE, SEEK_SET);
            size_t readSize = fread(buffer, 1, SECTOR_SIZE, boot);
            fclose(boot);

            // 输出读取的数据
            for (size_t i = 0; i < readSize && bytesRead < fileSize; i++, bytesRead++) {
                putchar(buffer[i]); // 输出字符到控制台
            }
        }

        unsigned short nextClusNum = getClus(&disk.FAT1[currentCluster / 2].data[currentCluster % 2],
                                             currentCluster % 2);
        currentCluster = nextClusNum;

        // 如果获取的下一个簇是 ff8 ~ fff，结束读取
        if (currentCluster >= 0x0FF8) { // 对于 FAT12，0x0FF8 及以上的簇表示 EOF
            break;
        }
    }

    // 换行以结束输出
    cout << endl;
}

/**
 * 进入文件夹
 * @param _name
 */
void cd(string &_name) {
    string fileFullName = _name.substr(3); // 从 "cd " 后开始
    toLowerCase(fileFullName);
    if (fileFullName == ".") {
        cout << "已在当前目录" << endl;
        return;
    }
    if (fileFullName == "/") {
        uint16_t offset = (19) * SECTOR_SIZE;
        fseek(diskFile, offset, SEEK_SET);
        fread(disk.rootDirectory, 1, disk.MBR.BPB_RootEntCnt, diskFile);
        cout << "已回到根目录" << endl;
        return;
    }

    if (fileFullName == "..") {
        if (clusterStack.empty()) {
            return;
        }
        if (!clusterStack.empty()) {
//            if(!hasSubdirectories()){ //如果有子目录 弹出栈
//            }
            //上一层的簇号
            uint8_t tempClusterNum = clusterStack.top();
            clusterStack.pop(); // 弹出当前目录的簇号
            //特殊的回到根目录如果tempClusterNum =2
            if (tempClusterNum == 2) {
                uint16_t offset = (19 + (tempClusterNum - 2)) * SECTOR_SIZE;
                fseek(diskFile, offset, SEEK_SET);
                fread(disk.rootDirectory, 1, disk.MBR.BPB_RootEntCnt, diskFile);
                cout << "已返回上一级目录" << endl;
                return;
            }
            uint16_t offset = (33 + (tempClusterNum - 2)) * SECTOR_SIZE;
            fseek(diskFile, offset, SEEK_SET);
            fread(disk.rootDirectory, 1, disk.MBR.BPB_RootEntCnt, diskFile);
            return;
        } else {
            cout << "当前已在根目录" << endl;
        }
        return;
    }

    for (uint16_t i = 0; i < disk.MBR.BPB_RootEntCnt; i++) {
        if (disk.rootDirectory[i].DIR_Name[0] == 0) continue; //跳过空目录项
        //文件名整理以便比较
        uint8_t file_name[9];
        memcpy(file_name, disk.rootDirectory[i].DIR_Name, 8);
        file_name[8] = '\0';
        string actual_name(reinterpret_cast<char *>(file_name));
        actual_name = actual_name.substr(0, actual_name.find_last_not_of(' ') + 1);
        toLowerCase(actual_name);

        if (fileFullName == actual_name && (disk.rootDirectory[i].DIR_Attr & 0x10)) { //如果是目录
            uint16_t cluster = disk.rootDirectory[i].DIR_FstClus;

            if (clusterStack.empty()) clusterStack.push(2);
            clusterStack.push(cluster);

            uint16_t offset = (33 + (cluster - 2)) * SECTOR_SIZE;
            fseek(diskFile, offset, SEEK_SET);
            fread(disk.rootDirectory, 1, disk.MBR.BPB_RootEntCnt, diskFile);

            cout << "进入目录：" << actual_name << endl;
            return;
        }
    }
    cout << "未找到目录: " << fileFullName << endl;
}

/**
 * 实现命令汇总
 * @param command
 */
void executeCommand(string &command) {
    if (command == "dir") {
        dir(); // 显示根目录的结构
    } else if (command == "exit") {
        cout << "退出程序..." << endl;
        exit(0);
    } else if (command.substr(0, 4) == "cat ") { // 必须是 cat空格 命令开头
        cat(command); // 调用 cat 函数
    } else if (command.substr(0, 6) == "mkdir ") {
        mkdir(command);
    } else if (command.substr(0, 3) == "cd ") { // 必须是 cd空格 命令开头
        cd(command); // 调用 cd 函数
    } else if (command == "te") { //过程测试
        te(clusterStack);
    } else {
        cout << "未知命令: " << command << endl;
    }
}

/**
 * 查看文件内容
 * @param _name
 */
void cat(string &_name) {
    // 提取文件名
    string fileFullName = _name.substr(4); // 从 "cat " 后开始
    // 查找文件条目
    RootEntry *fileEntry = findFile(fileFullName);
    if (fileEntry) {
        // 如果找到文件条目，输出找到的文件信息
//        cout << "起始簇号" << fileEntry->DIR_FstClus << "号簇" << endl;
//        cout << "文件大小: " << fileEntry->DIR_FileSize << " 字节" << endl;
        uint16_t firstCluster = fileEntry->DIR_FstClus;
        readFileData(firstCluster, fileEntry->DIR_FileSize);
    } else {
        cout << "文件未找到: " << fileFullName << endl;
    }
}


void setTime(RootEntry &entry) {
    time_t currentTime = time(NULL);
    tm *localTime = localtime(&currentTime);

    // 获取并构造最后一次写入日期（16位）
    uint16_t lastWriteDate = ((localTime->tm_year - 80) << 9) |
                             ((localTime->tm_mon + 1) << 5) |
                             localTime->tm_mday;

    // 获取并构造最后一次写入时间（16位）
    uint16_t lastWriteTime = (localTime->tm_hour << 11) |
                             (localTime->tm_min << 5) |
                             0b00000; // 秒数可以设为0或其他值

    // 将构造的时间和日期存储到结构体中
    entry.DIR_WrtDate[0] = lastWriteDate & 0xFF;           // 低字节
    entry.DIR_WrtDate[1] = (lastWriteDate >> 8) & 0xFF;    // 高字节
    entry.DIR_WrtTime[0] = lastWriteTime & 0xFF;           // 低字节
    entry.DIR_WrtTime[1] = (lastWriteTime >> 8) & 0xFF;    // 高字节
}

void printRootEntry(const RootEntry &entry) {
    // 打印文件名
    cout << "文件名: ";
    for (int i = 0; i < 11; ++i) {
        cout << entry.DIR_Name[i];
    }
    cout << endl;
    // 打印文件属性
    cout << "文件属性: 0x" << hex << setw(2) << setfill('0') << static_cast<int>(entry.DIR_Attr) << endl;

    // 打印保留位
    cout << "保留位: ";
    for (int i = 0; i < 10; ++i) {
        cout << "0x" << hex << setw(2) << setfill('0') << static_cast<int>(entry.DIR_reserve[i]) << " ";
    }
    cout << endl;

    // 打印最后一次写入时间
    cout << "最后一次写入时间: "
         << static_cast<int>(entry.DIR_WrtTime[0]) << ":"
         << static_cast<int>(entry.DIR_WrtTime[1]) << endl;

    // 打印最后一次写入日期
    cout << "最后一次写入日期: "
         << static_cast<int>(entry.DIR_WrtDate[0]) << "-"
         << static_cast<int>(entry.DIR_WrtDate[1]) << endl;

    // 打印文件开始的簇号
    cout << "文件开始的簇号: " << entry.DIR_FstClus << endl;

    // 打印文件大小
    cout << "文件大小: " << entry.DIR_FileSize << " 字节" << endl;
}

//文件夹名字
void mkdir(string &dirName) {
    RootEntry rootEntry;
    string fileFullName = dirName.substr(5);

    // 处理文件名
    char _name[11] = "";
    strncpy(_name, fileFullName.c_str(), 11);
    _name[11] = '\0';

    // 填充目录项
    memset(rootEntry.DIR_Name, 0x20, sizeof(rootEntry.DIR_Name)); // 空格填充
    strncpy(reinterpret_cast<char*>(rootEntry.DIR_Name), _name, 11);
    rootEntry.DIR_Attr = 0x10; // 目录属性
    memset(rootEntry.DIR_reserve, 0, sizeof(rootEntry.DIR_reserve));

    // 设置时间
    setTime(rootEntry);
    rootEntry.DIR_FileSize = 512; // 初始大小

    uint16_t cluster_num_allocated = allocateFATCluster();
    if (cluster_num_allocated == 0xFFFF) {
        cout << "所有簇都被分配了" << endl;
        return;
    }
    rootEntry.DIR_FstClus = cluster_num_allocated;

    // 更新根目录
    for (int i = 0; i < 1536; ++i) {
        if (disk.rootDirectory[i].DIR_Name[0] == 0x00) { // 找到空闲目录项
            disk.rootDirectory[i] = rootEntry; // 更新内存中的根目录
            cout << "目录创建成功, 簇号是: " << cluster_num_allocated << endl;

            // 写入更新到磁盘
            // 确保指针有效

            // 设置文件指针到根目录起始位置
            fseek(diskFile, 19*512, SEEK_SET); // ROOT_DIR_START 是根目录在磁盘上的起始偏移量
            // 写入根目录内容到磁盘
            fwrite(&rootEntry, sizeof(RootEntry), 1, diskFile);

            return;
        }
    }

    cout << "根目录已满，无法添加新目录。" << endl;
}


int main() {
    showCommandList();
    Init();
    while (true) {
        cout << "A>:";
        getline(cin, command);
        executeCommand(command);
    }
}